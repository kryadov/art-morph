(()=>{const e=e=>document.querySelector(e),t=document.getElementById("glcanvas"),n=document.getElementById("gl-fallback"),a={palette:e("#palette"),iterations:e("#iterations"),zoom:e("#zoom"),rotation:e("#rotation"),speed:e("#speed"),playPause:e("#playPause"),reset:e("#reset"),iterationsValue:e("#iterationsValue"),zoomValue:e("#zoomValue"),rotationValue:e("#rotationValue"),speedValue:e("#speedValue")},o={palette:0,maxIter:200,scale:1,rotationDeg:0,speed:1,playing:!0,center:{x:-.2,y:0}};let i=null,r=null,c=null,l={},s={},u=Math.min(window.devicePixelRatio||1,2),d=performance.now(),h=0,p=!0;function m(e,t){const n=i.createShader(e);if(i.shaderSource(n,t),i.compileShader(n),!i.getShaderParameter(n,i.COMPILE_STATUS)){const e=i.getShaderInfoLog(n);throw i.deleteShader(n),new Error("Shader compile error: "+e)}return n}function g(){r=function(e,t){const n=m(i.VERTEX_SHADER,e),a=m(i.FRAGMENT_SHADER,t),o=i.createProgram();if(i.attachShader(o,n),i.attachShader(o,a),i.bindAttribLocation(o,0,"a_position"),i.linkProgram(o),i.deleteShader(n),i.deleteShader(a),!i.getProgramParameter(o,i.LINK_STATUS)){const e=i.getProgramInfoLog(o);throw i.deleteProgram(o),new Error("Program link error: "+e)}return o}("\nattribute vec2 a_position;\nvoid main() {\n  gl_Position = vec4(a_position, 0.0, 1.0);\n}","\nprecision highp float;\n\nuniform vec2 u_resolution;  // canvas size in pixels\nuniform vec2 u_center;      // complex plane center\nuniform float u_span;       // base span scaled by zoom (width of plane)\nuniform float u_rotation;   // radians\nuniform float u_time;       // seconds\nuniform int u_maxIter;\nuniform int u_palette;      // 0=Khokhloma,1=Gzhel,2=Rainbow\n\n// Utility: rotate 2D vector\nmat2 rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\n// Convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + vec3(0., 2./6., 4./6.)) * 6. - 3.);\n  vec3 rgb = clamp(p - 1., 0., 1.);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n// Khokhloma-inspired palette: deep reds to gold with black background\nvec3 paletteKhokhloma(float t) {\n  // Clamp and ease\n  t = clamp(t, 0., 1.);\n  // Color stops\n  vec3 c0 = vec3(0.02, 0.0, 0.0);     // near black with hint of red\n  vec3 c1 = vec3(0.35, 0.0, 0.02);    // deep crimson\n  vec3 c2 = vec3(0.8, 0.15, 0.0);     // red-orange\n  vec3 c3 = vec3(1.0, 0.65, 0.0);     // gold\n  vec3 c4 = vec3(1.0, 0.9, 0.4);      // pale gold/white\n  if (t < 0.25) return mix(c0, c1, smoothstep(0., 0.25, t));\n  if (t < 0.5)  return mix(c1, c2, smoothstep(0.25, 0.5, t));\n  if (t < 0.8)  return mix(c2, c3, smoothstep(0.5, 0.8, t));\n  return mix(c3, c4, smoothstep(0.8, 1.0, t));\n}\n\n// Gzhel-inspired palette: deep blue to white porcelain\nvec3 paletteGzhel(float t) {\n  t = clamp(t, 0., 1.);\n  vec3 c0 = vec3(0.02, 0.05, 0.12);   // near black/blue\n  vec3 c1 = vec3(0.05, 0.25, 0.65);   // cobalt\n  vec3 c2 = vec3(0.35, 0.55, 0.95);   // light blue\n  vec3 c3 = vec3(0.92, 0.96, 1.0);    // porcelain white\n  if (t < 0.4) return mix(c0, c1, smoothstep(0., 0.4, t));\n  if (t < 0.75) return mix(c1, c2, smoothstep(0.4, 0.75, t));\n  return mix(c2, c3, smoothstep(0.75, 1.0, t));\n}\n\nvec3 paletteRainbow(float t) {\n  return hsv2rgb(vec3(fract(t + 0.0), 0.85, 1.0));\n}\n\nvec3 getPalette(float t, int which) {\n  if (which == 0) return paletteKhokhloma(t);\n  if (which == 1) return paletteGzhel(t);\n  return paletteRainbow(t);\n}\n\n// Continuous coloring for Julia set\nvoid main() {\n  // Map pixel to complex plane, keeping aspect ratio\n  vec2 uv = (gl_FragCoord.xy / u_resolution) * 2.0 - 1.0; // [-1,1]\n  float aspect = u_resolution.x / max(1.0, u_resolution.y);\n  uv.x *= aspect;\n\n  // span defines width of plane; scale uv accordingly and rotate\n  vec2 z = (rot(u_rotation) * uv) * (u_span * 0.5) + u_center;\n\n  // Animate c over time to morph shapes\n  float t = u_time * 0.25; // slow down a bit\n  vec2 c = vec2(0.285 + 0.25*cos(t*1.7), 0.01 + 0.25*sin(t*1.2));\n\n  // Iterate Julia: z = z^2 + c\n  int maxIter = u_maxIter;\n  float i;\n  float trap = 1e9; // distance estimator trap (optional)\n  for (i = 0.0; i < 2000.0; i++) {\n    if (int(i) >= maxIter) break;\n    // z^2 in complex\n    vec2 z2 = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n    z = z2;\n    float r2 = dot(z, z);\n    trap = min(trap, abs(z.x) + abs(z.y));\n    if (r2 > 256.0) break; // bailout\n  }\n\n  float colorT;\n  if (int(i) >= maxIter) {\n    // inside set: dark shade with trap coloring\n    colorT = 0.0;\n  } else {\n    // Smooth iteration count\n    float r = length(z);\n    float nu = i - log2(log2(max(r, 1.001))) + 4.0;\n    colorT = nu / float(maxIter);\n  }\n\n  // Subtle modulation by orbit trap to add detail\n  colorT = clamp(colorT + 0.15 * exp(-3.0*trap), 0.0, 1.0);\n  vec3 col = getPalette(colorT, u_palette);\n\n  // Vignette for aesthetics\n  float d = length(uv);\n  float vig = smoothstep(1.2, 0.2, d);\n  col *= mix(0.85, 1.0, vig);\n\n  gl_FragColor = vec4(col, 1.0);\n}"),i.useProgram(r);const e=new Float32Array([-1,-1,1,-1,-1,1,1,-1,1,1,-1,1]);c=i.createBuffer(),i.bindBuffer(i.ARRAY_BUFFER,c),i.bufferData(i.ARRAY_BUFFER,e,i.STATIC_DRAW),l.a_position=0,i.enableVertexAttribArray(l.a_position),i.vertexAttribPointer(l.a_position,2,i.FLOAT,!1,0,0),s.u_resolution=i.getUniformLocation(r,"u_resolution"),s.u_center=i.getUniformLocation(r,"u_center"),s.u_span=i.getUniformLocation(r,"u_span"),s.u_rotation=i.getUniformLocation(r,"u_rotation"),s.u_time=i.getUniformLocation(r,"u_time"),s.u_maxIter=i.getUniformLocation(r,"u_maxIter"),s.u_palette=i.getUniformLocation(r,"u_palette"),i.disable(i.DEPTH_TEST),i.disable(i.CULL_FACE),i.clearColor(0,0,0,1)}function v(){const e=t.getBoundingClientRect(),n=Math.min(window.devicePixelRatio||1,2);n!==u&&(u=n);const a=Math.max(1,Math.floor(e.width*u)),o=Math.max(1,Math.floor(e.height*u));t.width===a&&t.height===o||(t.width=a,t.height=o,i.viewport(0,0,a,o),p=!0)}function f(){a.iterationsValue.textContent=String(o.maxIter),a.zoomValue.textContent=o.scale.toFixed(2)+"×",a.rotationValue.textContent=Math.round(o.rotationDeg)+"°",a.speedValue.textContent=o.speed.toFixed(2)+"×"}function x(){i&&(v(),i.clear(i.COLOR_BUFFER_BIT),i.uniform2f(s.u_resolution,t.width,t.height),i.uniform2f(s.u_center,o.center.x,o.center.y),i.uniform1f(s.u_span,3*o.scale),i.uniform1f(s.u_rotation,o.rotationDeg*Math.PI/180),i.uniform1f(s.u_time,h*o.speed),i.uniform1i(s.u_maxIter,0|o.maxIter),i.uniform1i(s.u_palette,0|o.palette),i.drawArrays(i.TRIANGLES,0,6))}let _=0;function w(e){const t=(e-d)/1e3;d=e,o.playing&&(h+=t,p=!0),p&&(x(),p=!1),_=requestAnimationFrame(w)}function y(){cancelAnimationFrame(_),d=performance.now(),_=requestAnimationFrame(w)}let b=!1,L={x:0,y:0},S={active:!1,d0:0,scale0:1};function z(e,t){b=!0,L.x=e,L.y=t}function E(e,n){if(!b||S.active)return;const a=e-L.x,i=n-L.y;L.x=e,L.y=n;const r=function(e,n){const a=3*o.scale,i=t.width/Math.max(1,t.height),r=e/t.width*a*i,c=-n/t.height*a,l=o.rotationDeg*Math.PI/180,s=Math.cos(l),u=Math.sin(l);return{x:s*r-u*c,y:u*r+s*c}}(a,i);o.center.x-=r.x,o.center.y-=r.y,p=!0}function M(){b=!1}function I(e,t){const n=e.clientX-t.clientX,a=e.clientY-t.clientY;return Math.hypot(n,a)}function P(){try{!function(){const e={antialias:!1,preserveDrawingBuffer:!1,alpha:!1,powerPreference:"high-performance"};if(i=t.getContext("webgl",e)||t.getContext("experimental-webgl",e),!i)throw new Error("WebGL not supported");t.addEventListener("webglcontextlost",e=>{e.preventDefault(),cancelAnimationFrame(_)}),t.addEventListener("webglcontextrestored",()=>{g(),p=!0,y()})}(),g()}catch(t){return console.error(t),e="WebGL failed to initialize: "+t.message,void(n&&(n.classList.remove("hidden"),n.textContent=e||n.textContent))}var e;a.palette.value=String(o.palette),a.iterations.value=String(o.maxIter),a.zoom.value=String(o.scale),a.rotation.value=String(o.rotationDeg),a.speed.value=String(o.speed),f(),a.palette.addEventListener("input",e=>{o.palette=parseInt(e.target.value,10),p=!0,f()}),a.iterations.addEventListener("input",e=>{o.maxIter=parseInt(e.target.value,10),p=!0,f()}),a.zoom.addEventListener("input",e=>{o.scale=parseFloat(e.target.value),p=!0,f()}),a.rotation.addEventListener("input",e=>{o.rotationDeg=parseFloat(e.target.value),p=!0,f()}),a.speed.addEventListener("input",e=>{o.speed=parseFloat(e.target.value),p=!0,f()}),a.playPause.addEventListener("click",()=>{o.playing=!o.playing,a.playPause.textContent=o.playing?"Pause":"Play",a.playPause.setAttribute("aria-pressed",String(o.playing)),p=!0}),a.reset.addEventListener("click",()=>{Object.assign(o,{palette:0,maxIter:200,scale:1,rotationDeg:0,speed:1,playing:!0,center:{x:-.2,y:0}}),a.palette.value=String(o.palette),a.iterations.value=String(o.maxIter),a.zoom.value=String(o.scale),a.rotation.value=String(o.rotationDeg),a.speed.value=String(o.speed),a.playPause.textContent="Pause",a.playPause.setAttribute("aria-pressed","true"),p=!0,f()}),t.style.width="100%",t.style.height="100%",v(),x(),y()}t.addEventListener("touchstart",e=>{1===e.touches.length?z(e.touches[0].clientX,e.touches[0].clientY):2===e.touches.length&&(S.active=!0,S.d0=I(e.touches[0],e.touches[1]),S.scale0=o.scale)},{passive:!1}),t.addEventListener("touchmove",e=>{if(e.preventDefault(),1!==e.touches.length||S.active){if(2===e.touches.length){const t=I(e.touches[0],e.touches[1]),n=S.d0/Math.max(1,t);o.scale=Math.min(10,Math.max(.1,S.scale0*n)),a.zoom.value=String(o.scale),f(),p=!0}}else E(e.touches[0].clientX,e.touches[0].clientY)},{passive:!1}),t.addEventListener("touchend",()=>{S.active=!1,M()}),t.addEventListener("mousedown",e=>z(e.clientX,e.clientY)),window.addEventListener("mousemove",e=>E(e.clientX,e.clientY)),window.addEventListener("mouseup",M),t.addEventListener("wheel",function(e){e.preventDefault();const n=Math.exp(.001*-e.deltaY),i=t.getBoundingClientRect(),r=(e.clientX-i.left)*u,c=(e.clientY-i.top)*u,l=t.width/Math.max(1,t.height),s=(r/t.width*2-1)*l,d=c/t.height*2-1,h=o.rotationDeg*Math.PI/180,m=Math.cos(h)*s-Math.sin(h)*d,g=Math.sin(h)*s+Math.cos(h)*d,v=3*o.scale,x=m*(.5*v)+o.center.x,_=g*(.5*v)+o.center.y;o.scale=Math.min(10,Math.max(.1,o.scale/n)),a.zoom.value=String(o.scale);const w=3*o.scale,y=m*(.5*w)+o.center.x,b=g*(.5*w)+o.center.y;o.center.x+=x-y,o.center.y+=_-b,f(),p=!0},{passive:!1}),t.addEventListener("dblclick",function(e){const n=t.getBoundingClientRect(),a=(e.clientX-n.left)*u,i=(e.clientY-n.top)*u,r=t.width/Math.max(1,t.height),c={x:a/t.width*2-1,y:i/t.height*2-1};c.x*=r;const l=o.rotationDeg*Math.PI/180,s=Math.cos(l)*c.x-Math.sin(l)*c.y,d=Math.sin(l)*c.x+Math.cos(l)*c.y,h=3*o.scale;o.center.x=s*(.5*h)+o.center.x,o.center.y=d*(.5*h)+o.center.y,p=!0}),window.addEventListener("resize",()=>{p=!0}),"loading"===document.readyState?document.addEventListener("DOMContentLoaded",P):P()})();