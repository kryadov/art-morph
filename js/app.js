(()=>{"use strict";const e=[{id:0,name:"Julia Set",type:"shader",defaults:{maxIter:200,scale:1,rotationDeg:0,center:{x:-.2,y:0}},glsl:"\n// Compute color for Julia set at point z0\nvec3 colorJulia(vec2 z0) {\n  vec2 z = z0;\n  // Animate c over time to morph shapes\n  float t = u_time * 0.25; // slow down a bit\n  vec2 c = vec2(0.285 + 0.25*cos(t*1.7), 0.01 + 0.25*sin(t*1.2));\n\n  int maxIter = u_maxIter;\n  float i = 0.0;\n  float trap = 1e9;\n  for (int ii = 0; ii < 500; ii++) {\n    i = float(ii);\n    if (ii >= maxIter) break;\n    vec2 z2 = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n    z = z2;\n    float r2 = dot(z, z);\n    trap = min(trap, abs(z.x) + abs(z.y));\n    if (r2 > 256.0) break;\n  }\n\n  float colorT;\n  if (int(i) >= maxIter) {\n    colorT = 0.0;\n  } else {\n    float r = length(z);\n    float nu = i - log2(log2(max(r, 1.001))) + 4.0;\n    colorT = nu / float(maxIter);\n  }\n  colorT = clamp(colorT + 0.15 * exp(-3.0*trap), 0.0, 1.0);\n  return getPalette(colorT, u_palette);\n}\n"},{id:1,name:"Sierpinski Triangle",type:"shader",defaults:{maxIter:9,scale:1.2,rotationDeg:0,center:{x:0,y:0}},glsl:"\n// Sierpinski Triangle test using base-2 fractional folding\n// Returns t in [0,1], where lower values indicate earlier removal (more hollow)\nfloat sierpinskiTri(vec2 pNorm) {\n  vec2 q = pNorm;\n  float tLevel = 1.0;\n  for (int ii = 0; ii < 1024; ii++) {\n    if (ii >= u_maxIter) break;\n    vec2 r = fract(q * 2.0);\n    // In a unit triangle tiling, points with r.x + r.y > 1 are in the 'removed' central region\n    if (r.x + r.y > 1.0) {\n      tLevel = float(ii) / max(1.0, float(u_maxIter));\n      return tLevel; // early removal\n    }\n    q = r;\n  }\n  return 1.0; // never removed => deepest level\n}\n"},{id:2,name:"Sierpinski Carpet",type:"shader",defaults:{maxIter:6,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\n// Sierpinski Carpet using base-3 digit test\nfloat sierpinskiCarpet(vec2 pNorm) {\n  vec2 q = pNorm;\n  float tLevel = 1.0;\n  for (int ii = 0; ii < 1024; ii++) {\n    if (ii >= u_maxIter) break;\n    vec2 r = fract(q * 3.0);\n    if (r.x > 1.0/3.0 && r.x < 2.0/3.0 && r.y > 1.0/3.0 && r.y < 2.0/3.0) {\n      tLevel = float(ii) / max(1.0, float(u_maxIter));\n      return tLevel;\n    }\n    q = r;\n  }\n  return 1.0;\n}\n"},{id:3,name:"Menger Sponge",type:"shader",defaults:{maxIter:5,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\nfloat isMiddleThird(float a) {\n  return step(1.0/3.0, a) * step(a, 2.0/3.0);\n}\n\n// Menger Sponge membership depth using base-3 rule: removed if at any level, at least two axes in middle third\nfloat mengerDepth(vec3 p) {\n  vec3 q = p;\n  for (int ii = 0; ii < 128; ii++) {\n    if (ii >= u_maxIter) break;\n    vec3 r = fract(q * 3.0);\n    float midCount = isMiddleThird(r.x) + isMiddleThird(r.y) + isMiddleThird(r.z);\n    if (midCount >= 2.0) {\n      return float(ii) / max(1.0, float(u_maxIter));\n    }\n    q = r;\n  }\n  return 1.0;\n}\n"},{id:4,name:"Sierpinski Pyramid",type:"shader",defaults:{maxIter:9,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\n// Sierpinski Pyramid (tetrahedral gasket) approximate rule: removed when x+y+y >1 in tri, generalized to 3D as sum > 1\nfloat sierpinskiPyramidDepth(vec3 p) {\n  vec3 q = p;\n  for (int ii = 0; ii < 128; ii++) {\n    if (ii >= u_maxIter) break;\n    vec3 r = fract(q * 2.0);\n    if (r.x + r.y + r.z > 1.0) {\n      return float(ii) / max(1.0, float(u_maxIter));\n    }\n    q = r;\n  }\n  return 1.0;\n}\n"},{id:5,name:"Koch Curve",type:"overlay",defaults:{maxIter:4,scale:1,rotationDeg:0,center:{x:0,y:0}},draw:(e,t,n,a)=>{const{pathMoveToNorm:o,pathLineToNorm:r}=a;t=Math.max(0,Math.min(6,0|t));let i="F";for(let e=0;e<t;e++){let e="";for(const t of i)e+="F"===t?"F+F--F+F":t;i=e}const l=Math.PI/3;let c=.1,s=.5,u=0;const f=.8/Math.pow(3,t);e.save(),e.lineWidth=Math.max(1,Math.floor(2*n)),e.strokeStyle="#eaeaea",e.beginPath(),o(c,s);for(const e of i)"F"===e?(c+=Math.cos(u)*f,s+=Math.sin(u)*f,r(c,s)):"+"===e?u+=l:"-"===e&&(u-=l);e.stroke(),e.restore()}},{id:6,name:"Peano Curve",type:"overlay",defaults:{maxIter:5,scale:1,rotationDeg:0,center:{x:0,y:0}},draw:(e,t,n,a)=>{const{pathMoveToNorm:o,pathLineToNorm:r}=a,i=function(e){let t="L";for(let n=0;n<e;n++){let e="";for(const n of t)e+="L"===n?"LFRFL-F-RFLFR+F+LFRFL":"R"===n?"RFLFR+F+LFRFL-F-RFLFR":n;t=e}return t}((t=Math.max(1,Math.min(5,0|t)))-1),l=Math.PI/2,c=.8/Math.pow(3,t-1);let s=.1,u=.1,f=0;e.save(),e.lineWidth=Math.max(1,Math.floor(2*n)),e.strokeStyle="#eaeaea",e.beginPath(),o(s,u);for(const e of i)"F"===e?(s+=Math.cos(f)*c,u+=Math.sin(f)*c,r(s,u)):"+"===e?f+=l:"-"===e&&(f-=l);e.stroke(),e.restore()}},{id:7,name:"Pythagoras Tree",type:"overlay",defaults:{maxIter:9,scale:1,rotationDeg:0,center:{x:0,y:0}},draw:(e,t,n,a)=>{const{worldFromNorm:o,planeToScreen:r}=a,i=Math.max(1,Math.min(10,0|t));e.save(),e.lineWidth=Math.max(1,Math.floor(1.2*n)),e.strokeStyle="#eaeaea",e.fillStyle="rgba(255,255,255,0.08)",function t(n,a,i,l){const c=function(t,n,a){const i=Math.cos(a)*(n/2),l=Math.sin(a)*(n/2),c=-Math.sin(a)*(n/2),s=Math.cos(a)*(n/2),u={x:t.x-i-c,y:t.y-l-s},f={x:t.x+i-c,y:t.y+l-s},m={x:t.x+i+c,y:t.y+l+s},p={x:t.x-i+c,y:t.y-l+s},d=r(o(u.x,u.y).x,o(u.x,u.y).y),h=r(o(f.x,f.y).x,o(f.x,f.y).y),g=r(o(m.x,m.y).x,o(m.x,m.y).y),v=r(o(p.x,p.y).x,o(p.x,p.y).y);return e.beginPath(),e.moveTo(d.x,d.y),e.lineTo(h.x,h.y),e.lineTo(g.x,g.y),e.lineTo(v.x,v.y),e.closePath(),e.fill(),e.stroke(),{p1:u,p2:f,p3:m,p4:p}}(n,a,i);if(l<=0)return;const s=a/Math.SQRT2,u=i-Math.PI/4,f=i+Math.PI/4,m=Math.cos(u)*(s/2),p=Math.sin(u)*(s/2),d=-Math.sin(u)*(s/2),h=Math.cos(u)*(s/2),g=Math.cos(f)*(s/2),v=Math.sin(f)*(s/2),x=-Math.sin(f)*(s/2),y=Math.cos(f)*(s/2),b={x:c.p4.x+m-d,y:c.p4.y+p-h},w={x:c.p3.x-g-x,y:c.p3.y-v-y};t(b,s,u,l-1),t(w,s,f,l-1)}({x:.5,y:.19},.18,0,i-1),e.restore()}},{id:8,name:"L-System Tree",type:"overlay",defaults:{maxIter:6,scale:1,rotationDeg:0,center:{x:0,y:0}},draw:(e,t,n,a)=>{const{pathMoveToNorm:o,pathLineToNorm:r,worldFromNorm:i,planeToScreen:l}=a;t=Math.max(1,Math.min(12,0|t));const c=[],s={X:"F-[[X]+X]+F[+FX]-X",F:"FF"};let u="X";const f=Math.min(5,t);for(let e=0;e<f;e++){let e="";for(const t of u)e+=s[t]||t;u=e}let m=.5,p=.95,d=-Math.PI/2;const h=.02*Math.max(1,t-2);e.save(),e.lineWidth=Math.max(1,Math.floor(1.5*n)),e.strokeStyle="#eaeaea",e.beginPath(),o(m,p);for(const t of u)if("F"===t){const e=m+Math.cos(d)*h,t=p+Math.sin(d)*h;r(e,t),m=e,p=t}else if("+"===t)d+=Math.PI/7;else if("-"===t)d-=Math.PI/7;else if("["===t)c.push({x:m,y:p,dir:d});else if("]"===t){const t=c.pop();if(!t)continue;m=t.x,p=t.y,d=t.dir,e.moveTo(l(i(m,p).x,i(m,p).y).x,l(i(m,p).x,i(m,p).y).y)}e.stroke(),e.restore()}},{id:9,name:"Stochastic Fern",type:"overlay",defaults:{maxIter:200,scale:1,rotationDeg:0,center:{x:0,y:0}},draw:(e,t,n,a,o)=>{const{worldFromNorm:r,planeToScreen:i}=a,l=Math.max(2e3,Math.min(4e4,200*(0|t))),c=4.8378,s=9.9983,u=c/s*.9,f=.5-.5*u,m=Math.max(1,Math.floor(1*n));e.save(),e.fillStyle="rgba(234,234,234,0.9)",o.ready||(o.x=0,o.y=0,o.ready=!0);let p=o.x,d=o.y;for(let t=0;t<l;t++){const t=Math.random();let n,a;t<.01?(n=0,a=.16*d):t<.86?(n=.85*p+.04*d,a=-.04*p+.85*d+1.6):t<.93?(n=.2*p-.26*d,a=.23*p+.22*d+1.6):(n=-.15*p+.28*d,a=.26*p+.24*d+.44),p=n,d=a;const o=r(f+(p- -2.182)/c*u,.05+(d-0)/s*.9),l=i(o.x,o.y);e.fillRect(l.x,l.y,m,m)}o.x=p,o.y=d,e.restore()}},{id:10,name:"Plasma",type:"shader",defaults:{maxIter:50,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\n// Plasma effect\nvec3 colorPlasma(vec2 p) {\n    float t = u_time * 0.5;\n    float v = 0.0;\n    v += sin(p.x * 8.0 + t);\n    v += sin((p.y * 5.0 - t) * 2.0);\n    v += sin((p.x + p.y + t) * 4.0);\n    vec2 p2 = p * 2.0;\n    v += sin(sqrt(p2.x*p2.x + p2.y*p2.y + 1.0) + t);\n    v = v / 4.0;\n    return getPalette(v, u_palette);\n}\n"},{id:11,name:"Dynamic Morph",type:"shader",defaults:{maxIter:8,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\n// Dynamic Morph\nvec3 colorDynamicMorph(vec3 p) {\n  vec3 q = p;\n  float t = u_time * 0.1;\n  for (int i = 0; i < 10; i++) {\n    if (i >= u_maxIter) break;\n    q = abs(q) / dot(q, q) - vec3(0.5 + 0.3*sin(t), 0.5 + 0.3*cos(t), 0.5 + 0.3*sin(t*1.2));\n  }\n  float colorT = fract(length(q) * 0.2);\n  colorT = 1.0 - abs(colorT * 2.0 - 1.0);\n  return getPalette(colorT, u_palette);\n}\n"},{id:12,name:"Star Journey",type:"shader",defaults:{maxIter:8,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\n// Star Journey (3D Raymarching)\nvec3 colorStarJourney(vec2 uv) {\n  // Camera flies forward: 0.5 (was 1.5) for 3x slower movement\n  vec3 ro = vec3(0.0, 0.0, u_time * 0.5);\n  vec3 rd = normalize(vec3(uv, 1.0));\n\n  // Rotate camera\n  float a = u_time * 0.1;\n  rd.xy *= rot(a);\n  rd.xz *= rot(a * 0.7);\n\n  float t = 0.0;\n  float minOrbit = 1e10;\n  int steps = 0;\n\n  // Pre-calculate animation offset\n  vec3 shift = vec3(0.5 * sin(u_time * 0.2), 0.3 * cos(u_time * 0.3), 0.0);\n\n  for (int i = 0; i < 40; i++) {\n    steps = i;\n    vec3 p = ro + rd * t;\n    // Repeat space\n    vec3 q = mod(p + 4.0, 8.0) - 4.0;\n\n    // Fractal DE: Simple recursive folding\n    float s = 1.0;\n    for (int j = 0; j < 5; j++) {\n      if (j >= u_maxIter / 2) break;\n      q = abs(q) - 1.2;\n      float r2 = dot(q, q);\n      minOrbit = min(minOrbit, r2);\n      float k = 2.0 / clamp(r2, 0.1, 1.5);\n      q *= k;\n      s *= k;\n      q += shift;\n    }\n    float d = (length(q) - 0.2) / s;\n    if (d < 0.001 || t > 40.0) break;\n    t += d * 0.7;\n  }\n\n  // Use minOrbit for smooth coloring. Log scale to compress the range and mirror palette.\n  float colorT = fract(log(1.0 + minOrbit) * 0.5 + u_time * 0.04);\n  colorT = 1.0 - abs(colorT * 2.0 - 1.0);\n  vec3 col = getPalette(colorT, u_palette);\n\n  // Simple lighting / fog\n  col *= 1.0 / (1.0 + t * t * 0.015);\n  // Soft glow based on steps\n  col += (float(steps) / 40.0) * 0.15 * col;\n\n  return col;\n}\n"},{id:13,name:"Liquid Gradient",type:"shader",defaults:{maxIter:30,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\nvec3 colorLiquid(vec2 p) {\n  float t = u_time * 0.15;\n  int baseOct = 1 + u_maxIter / 25;\n  if (baseOct > 3) baseOct = 3;\n  // Domain warping\n  vec2 q = vec2(fbm(p, baseOct), fbm(p + vec2(5.2, 1.3), baseOct));\n  vec2 r = vec2(fbm(p + 4.0*q + vec2(1.7, 9.2) + t, baseOct), fbm(p + 4.0*q + vec2(8.3, 2.8) + t*1.1, baseOct));\n  float f = fbm(p + 4.0*r, baseOct + 2);\n  return getPalette(clamp(f*f*3.5, 0.0, 1.0), u_palette);\n}\n"},{id:14,name:"3D Web",type:"shader",defaults:{maxIter:10,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:"\n// 3D Web (Iterative network with gradient)\nvec3 colorWeb3D(vec3 p) {\n  vec3 q = p;\n  float t = u_time * 0.15;\n  float minD = 1000.0;\n  for (int i = 0; i < 16; i++) {\n    if (i >= u_maxIter) break;\n    q = abs(q) - vec3(0.4, 0.4, 0.4);\n    float s = sin(t + float(i)*0.1);\n    float c = cos(t + float(i)*0.1);\n    q.xy = mat2(c, -s, s, c) * q.xy;\n    q.xz = mat2(c, -s, s, c) * q.xz;\n    q = q * 1.5 - vec3(0.2 * sin(t * 0.5));\n    // Orbit trap for web-like filaments\n    float dist = min(abs(q.x), min(abs(q.y), abs(q.z)));\n    minD = min(minD, dist);\n  }\n  float colorT = fract(log(1.0 + minD * 100.0) * 0.4 + t);\n  return getPalette(colorT, u_palette);\n}\n"},{id:15,name:"3D Bending Star",type:"shader",defaults:{maxIter:64,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:'\n// 3D Bending Star with Raymarching\nvec3 colorStar3D(vec2 uv) {\n  float camTime = u_time * 0.3;\n  // Camera orbits around the center\n  vec3 ro = vec3(5.0 * cos(camTime), 2.0 * sin(camTime * 0.4), 5.0 * sin(camTime));\n  vec3 target = vec3(0.0, 0.0, 0.0);\n  vec3 cw = normalize(target - ro);\n  vec3 cp = vec3(0.0, 1.0, 0.0);\n  vec3 cu = normalize(cross(cw, cp));\n  vec3 cv = normalize(cross(cu, cw));\n  vec3 rd = normalize(uv.x * cu + uv.y * cv + 2.0 * cw);\n\n  float t = 0.0;\n  float totalGlow = 0.0;\n  float minD = 1e10;\n\n  for (int i = 0; i < 100; i++) {\n    if (i >= u_maxIter) break;\n    vec3 p = ro + rd * t;\n\n    // Bending effect: rotate space based on distance from center\n    float r = length(p);\n    float bend = r * 0.2 - u_time * 0.6;\n    float s = sin(bend), c = cos(bend);\n    p.xz *= mat2(c, -s, s, c);\n    p.xy *= mat2(c, -s, s, c);\n\n    // Star SDF: Core + multiple rays\n    float core = length(p) - 0.25;\n\n    float rays = 1e10;\n    vec3 qR = p;\n    float thick = 0.008 * (1.0 + 2.0 / (r + 0.1));\n    for (int j = 0; j < 6; j++) {\n      rays = min(rays, min(length(qR.yz), min(length(qR.xz), length(qR.xy))));\n      qR.xy *= rot(0.8);\n      qR.yz *= rot(0.5);\n    }\n    rays -= thick;\n\n    float d = min(core, rays);\n    minD = min(minD, d);\n\n    // Accumulate glow, stronger near the center\n    totalGlow += exp(-d * 10.0) * (1.0 / (1.0 + r * 0.5));\n\n    if (d < 0.001 || t > 20.0) break;\n    t += d * 0.5;\n  }\n\n  // Base color from palette\n  float colorT = fract(u_time * 0.05 + minD);\n  vec3 col = getPalette(colorT, u_palette);\n\n  // Apply intense glow for "bright inside"\n  col += vec3(1.0, 0.9, 0.6) * totalGlow * 0.2;\n\n  // Exponential fog\n  col *= exp(-0.15 * t);\n\n  return col;\n}\n'},{id:16,name:"Energy Core",type:"shader",defaults:{maxIter:50,scale:1,rotationDeg:0,center:{x:0,y:0}},glsl:'\n#define PI 3.14159265359\n// Energy Core: Infinite flight to the center\nvec3 colorEnergyCore(vec2 z) {\n  float t = u_time * 0.7;\n  float r = length(z);\n  float angle = atan(z.y, z.x);\n\n  // Breathing effect: пульсация радиуса, амплитуды шумов и яркости\n  float pulse = sin(u_time * 1.5);\n  float breathing = 1.0 + 0.1 * pulse;\n\n  // Infinite flight effect (logarithmic zoom)\n  // Everything expands from center: log(r) - t\n  float logR = log(r + 1e-6) - t;\n\n  // 1. Spiral twist 3x greater\n  // We add logR-dependent twist to the angle.\n  // Combined with wavePattern\'s logR*10, this results in logR*30 (3x increase).\n  angle += logR * 20.0;\n\n  // Multiple Electric Rings (голубой/лазурный) approaching (expanding)\n  float multiRings = 0.0;\n  float spiralRings = 0.0;\n  float arcs = 0.0;\n  float ringDensity = 0.3; // How many rings in flight\n\n  // We check a few potential ring indices that could be visible\n  for (int i = -2; i <= 1; i++) {\n    float ringIdx = floor(logR * ringDensity) + float(i);\n    // Project ring index back to radius: r = exp(t + (ringIdx + 0.5) / ringDensity)\n    float ringRadius = exp(t + (ringIdx + 0.5) / ringDensity);\n\n    // Only render if within visible range\n    if (ringRadius < 0.01 || ringRadius > 4.0) continue;\n\n    // Jagged lightning-like displacement for the ring\n    float ringNoise = sin(angle * 6.0 + t * 0.2 + ringIdx * 12.3) * 0.5 + 0.5;\n    float ringJagged = (abs(fract(angle / (2.0 * PI) + ringIdx) - 0.5) - 0.25) * 0.5;\n    ringJagged += (ringNoise - 0.5) * 0.3;\n\n    float dist = abs(r - ringRadius + ringJagged * ringRadius * 0.4 * breathing);\n\n    // Sharper ring (cusp profile instead of gaussian) and thinner\n    float ringIntensity = exp(-dist * (180.0 / (ringRadius * (1.0 + 0.3 * pulse))));\n\n    // 1. Rings disappear at a random distance up to 30% to the camera\n    // Camera is roughly at r=1.2. 30% of 1.2 is 0.36.\n    // Random threshold between 0.84 and 1.2 based on ring index\n    float rand = fract(sin(ringIdx * 123.456) * 789.012);\n    float randomThreshold = 0.84 + 0.36 * rand;\n    float fade = smoothstep(randomThreshold, randomThreshold * 0.8, ringRadius) * smoothstep(0.0, 0.1, ringRadius);\n    multiRings += ringIntensity * fade;\n\n    // Flickering lightning arcs for each ring\n    // Use u_maxIter to scale complexity if needed (here we just optimize calculations)\n    int numArcs = 3;\n    for (int j = 0; j < 3; j++) {\n      float fj = float(j);\n      float a = angle + t * (1.2 + fj * 0.4 + ringIdx * 0.1) + fj * 2.1 + ringIdx;\n\n      // Optimized lightning-like jagged displacement: use sin instead of noise for GPU speed\n      float jagged = abs(fract(a * 1.5 + t * 0.5) - 0.5) * 0.4;\n      jagged += sin(a * 12.0 + t * 3.0 + ringIdx) * 0.2;\n      jagged += sin(a * 25.0 - t * 5.0 + fj) * 0.1;\n\n      float arcLine = abs(r - ringRadius + 0.12 * (jagged - 0.4) * breathing * ringRadius);\n      float arcInner = exp(-arcLine * (140.0 / ringRadius));\n\n      // Flickering using a hash-like sine function based on ring and time\n      float flicker = step(0.65, fract(sin(ringIdx * 17.8 + fj * 45.2 + floor(t * 22.0)) * 43758.5));\n      arcs += arcInner * flicker * fade;\n    }\n  }\n\n  // Дополнительные спиральные кольца в тоннеле (бесконечная спираль)\n  // Случайная модуляция частоты и амплитуды спирали\n  float spiralFM = noise(vec2(t * 0.3, logR * 0.3)) * 4.0;\n  // Используем cos(angle) для бесшовности по углу\n  float spiralAM = noise(vec2(t * 0.4, cos(angle) * 0.5 + 0.5)) * 0.5 + 0.5;\n  float spiralFreq = 8.0 + spiralFM;\n  float spiralAngleMult = 1.0;\n  float spiralVal = logR * spiralFreq + angle * spiralAngleMult;\n\n  // Создаем эффект непрерывной спирали через sin\n  float sDist = abs(fract(spiralVal / (2.0 * PI) + 0.5) - 0.5) * ((2.0 * PI) / spiralFreq);\n  float sIntensity = exp(-sDist * 40.0 / r) * spiralAM; // Толщина зависит от радиуса и модуляции\n\n  // Увеличиваем дальность видимости спирали к центру\n  float sFade = smoothstep(2.5, 1.2, r) * smoothstep(0.005, 0.05, r);\n  spiralRings = sIntensity * sFade;\n\n  // Plasma waves (фиолетово-синие оттенки) spreading outward\n  // Случайная амплитудно-частотная модуляция с эффектом размытия (smear)\n  float waveFM = noise(vec2(t * 0.4, logR * 0.2)) * 6.0;\n  // Используем cos(angle) для бесшовности\n  float waveAM = noise(vec2(t * 0.5, cos(angle) * 0.5 + 0.5)) * 0.4 + 0.6;\n\n  // Используем полярные координаты для шума, чтобы растянуть его вдоль тоннеля\n  // Низкая частота по logR и более высокая по angle создает радиальные полосы\n  // Для бесшовности по углу используем cos(angle)\n  float n = noise(vec2(logR * 1.5 - t * 0.2, cos(angle) * 0.5 + 0.5));\n\n  // Уменьшаем частоту по logR и увеличиваем по angle, чтобы уйти от формы кругов\n  // Множитель угла должен быть целым числом для бесшовности (убираем линию на 180 градусах)\n  float waveAngleMult = 7.0;\n  float wavePattern = sin(logR * (4.0 + waveFM) + angle * waveAngleMult + t + n * 6.0);\n\n  // Смешиваем паттерн с шумом для более "размазанного" вида\n  float plasma = smoothstep(-0.5, 1.0, wavePattern * waveAM + n * 0.4) * exp(-r * 0.8);\n\n  // 3. Palette should influence colors\n  vec3 colorLow = getPalette(0.1, u_palette);\n  vec3 colorMid = getPalette(0.5, u_palette);\n  vec3 colorHigh = getPalette(0.9, u_palette);\n  vec3 coreCol = colorLow * 0.2;\n\n  vec3 col = vec3(0.0);\n\n  // Plasma background (waves of violet-blue) using palette\n  vec3 plasmaCol = mix(colorLow, colorMid, sin(logR * 2.0 + t + n) * 0.5 + 0.5);\n  col += plasmaCol * plasma * 0.6;\n\n  // The electric rings using palette\n  col += colorHigh * multiRings * (2.2 + 0.8 * pulse);\n\n  // Extra spiral rings using palette\n  col += colorMid * spiralRings * 1.5;\n\n  // Arcs (extra bright palette color / white)\n  col += mix(colorHigh, vec3(1.0), 0.4) * arcs * 2.2;\n\n  // Energy Core at the end of the tunnel\n  float coreGlow = exp(-r * 25.0) * (2.0 + 1.0 * pulse);\n  vec3 coreGlowCol = colorHigh * coreGlow;\n\n  // Dark core masking\n  // В центре - тёмное ядро (почти чёрное)\n  float coreMask = smoothstep(0.02, 0.2 * breathing, r);\n  col *= coreMask;\n\n  // Add the energy core glow\n  col += coreGlowCol;\n\n  // Smoothly blend into the dark core for that "hole" look\n  col = mix(coreCol, col, smoothstep(0.01, 0.15, r));\n\n  return col;\n}\n'}],t=t=>e.find(e=>e.id===t);(()=>{const n=e=>document.querySelector(e),a=document.getElementById("glcanvas"),o=document.getElementById("overlay2d"),r=o?o.getContext("2d"):null,i=document.getElementById("gl-fallback"),l={controls:n("#controls"),fractal:n("#fractal"),palette:n("#palette"),iterations:n("#iterations"),zoom:n("#zoom"),rotation:n("#rotation"),speed:n("#speed"),playPause:n("#playPause"),reset:n("#reset"),recenter:n("#recenter"),musicFile:n("#musicFile"),musicPlay:n("#musicPlay"),musicStop:n("#musicStop"),iterationsValue:n("#iterationsValue"),zoomValue:n("#zoomValue"),rotationValue:n("#rotationValue"),speedValue:n("#speedValue")},c={fractalType:0,palette:0,maxIter:200,scale:1,rotationDeg:0,speed:1,playing:!0,center:{x:-.2,y:0}};let s=null,u=null,f=null,m={},p={},d=Math.min(window.devicePixelRatio||1,1.5),h=performance.now(),g=0,v=!0,x=!0,y={x:0,y:0,ready:!1},b=new Audio;b.loop=!0;let w=null;window.addEventListener("beforeunload",()=>{try{b.pause()}catch(e){}if(w){try{URL.revokeObjectURL(w)}catch(e){}w=null}});const M="ui.controlsHidden";function _(e){const t=l.controls;if(t){t.classList.toggle("hidden",!!e),t.setAttribute("aria-hidden",e?"true":"false");try{localStorage.setItem(M,e?"1":"0")}catch(e){}}}const S=(()=>{const t=e.filter(e=>"shader"===e.type);return`\nprecision highp float;\n\nuniform vec2 u_resolution;  // canvas size in pixels\nuniform vec2 u_center;      // complex plane center\nuniform float u_span;       // base span scaled by zoom (width of plane)\nuniform float u_rotation;   // radians\nuniform float u_time;       // seconds\nuniform int u_maxIter;\nuniform int u_palette;      // 0=Khokhloma,1=Gzhel,2=Rainbow,3=Sunset,4=Forest,5=Ocean,6=Neon,7=Monochrome\nuniform int u_fractalType;  // 0=Julia,1=Tri,2=Carpet,13=Liquid,14=Web3D\n\n// Utility: rotate 2D vector\nmat2 rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\n// Convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + vec3(0., 2./6., 4./6.)) * 6. - 3.);\n  vec3 rgb = clamp(p - 1., 0., 1.);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n// Khokhloma-inspired palette: deep reds to gold with black background\nvec3 paletteKhokhloma(float t) {\n  // Clamp and ease\n  t = clamp(t, 0., 1.);\n  // Color stops\n  vec3 c0 = vec3(0.02, 0.0, 0.0);     // near black with hint of red\n  vec3 c1 = vec3(0.35, 0.0, 0.02);    // deep crimson\n  vec3 c2 = vec3(0.8, 0.15, 0.0);     // red-orange\n  vec3 c3 = vec3(1.0, 0.65, 0.0);     // gold\n  vec3 c4 = vec3(1.0, 0.9, 0.4);      // pale gold/white\n  if (t < 0.25) return mix(c0, c1, smoothstep(0., 0.25, t));\n  if (t < 0.5)  return mix(c1, c2, smoothstep(0.25, 0.5, t));\n  if (t < 0.8)  return mix(c2, c3, smoothstep(0.5, 0.8, t));\n  return mix(c3, c4, smoothstep(0.8, 1.0, t));\n}\n\n// Gzhel-inspired palette: deep blue to white porcelain\nvec3 paletteGzhel(float t) {\n  t = clamp(t, 0., 1.);\n  vec3 c0 = vec3(0.02, 0.05, 0.12);   // near black/blue\n  vec3 c1 = vec3(0.05, 0.25, 0.65);   // cobalt\n  vec3 c2 = vec3(0.35, 0.55, 0.95);   // light blue\n  vec3 c3 = vec3(0.92, 0.96, 1.0);    // porcelain white\n  if (t < 0.4) return mix(c0, c1, smoothstep(0., 0.4, t));\n  if (t < 0.75) return mix(c1, c2, smoothstep(0.4, 0.75, t));\n  return mix(c2, c3, smoothstep(0.75, 1.0, t));\n}\n\nvec3 paletteRainbow(float t) {\n  return hsv2rgb(vec3(fract(t + 0.0), 0.85, 1.0));\n}\n\n// Sunset palette: deep blues to oranges and yellows\nvec3 paletteSunset(float t) {\n  t = clamp(t, 0., 1.);\n  vec3 c0 = vec3(0.05, 0.02, 0.15);  // dark midnight blue\n  vec3 c1 = vec3(0.4, 0.05, 0.4);    // purple\n  vec3 c2 = vec3(0.9, 0.3, 0.1);     // orange-red\n  vec3 c3 = vec3(1.0, 0.8, 0.2);     // yellow-gold\n  if (t < 0.3) return mix(c0, c1, smoothstep(0., 0.3, t));\n  if (t < 0.7) return mix(c1, c2, smoothstep(0.3, 0.7, t));\n  return mix(c2, c3, smoothstep(0.7, 1.0, t));\n}\n\n// Forest palette: dark greens to light lime\nvec3 paletteForest(float t) {\n  t = clamp(t, 0., 1.);\n  vec3 c0 = vec3(0.01, 0.05, 0.01);  // very dark green\n  vec3 c1 = vec3(0.1, 0.35, 0.15);   // forest green\n  vec3 c2 = vec3(0.4, 0.6, 0.2);     // olive/lime\n  vec3 c3 = vec3(0.8, 0.9, 0.5);     // pale spring green\n  if (t < 0.4) return mix(c0, c1, smoothstep(0., 0.4, t));\n  if (t < 0.7) return mix(c1, c2, smoothstep(0.4, 0.7, t));\n  return mix(c2, c3, smoothstep(0.7, 1.0, t));\n}\n\n// Ocean palette: deep sea to bright cyan/white\nvec3 paletteOcean(float t) {\n  t = clamp(t, 0., 1.);\n  vec3 c0 = vec3(0.02, 0.05, 0.2);   // deep blue\n  vec3 c1 = vec3(0.0, 0.4, 0.55);    // teal\n  vec3 c2 = vec3(0.2, 0.8, 0.85);    // cyan\n  vec3 c3 = vec3(0.9, 1.0, 1.0);     // water white\n  if (t < 0.35) return mix(c0, c1, smoothstep(0., 0.35, t));\n  if (t < 0.75) return mix(c1, c2, smoothstep(0.35, 0.75, t));\n  return mix(c2, c3, smoothstep(0.75, 1.0, t));\n}\n\n// Neon palette: dark to vibrant magenta and cyan\nvec3 paletteNeon(float t) {\n  t = clamp(t, 0., 1.);\n  vec3 c0 = vec3(0.05, 0.0, 0.1);    // dark purple\n  vec3 c1 = vec3(0.9, 0.0, 0.9);     // magenta\n  vec3 c2 = vec3(0.0, 0.9, 0.9);     // cyan\n  vec3 c3 = vec3(1.0, 1.0, 1.0);     // white\n  if (t < 0.4) return mix(c0, c1, smoothstep(0., 0.4, t));\n  if (t < 0.8) return mix(c1, c2, smoothstep(0.4, 0.8, t));\n  return mix(c2, c3, smoothstep(0.8, 1.0, t));\n}\n\n// Monochrome palette: black to white\nvec3 paletteMonochrome(float t) {\n  return vec3(clamp(t, 0., 1.));\n}\n\nvec3 getPalette(float t, int which) {\n  if (which == 0) return paletteKhokhloma(t);\n  if (which == 1) return paletteGzhel(t);\n  if (which == 2) return paletteRainbow(t);\n  if (which == 3) return paletteSunset(t);\n  if (which == 4) return paletteForest(t);\n  if (which == 5) return paletteOcean(t);\n  if (which == 6) return paletteNeon(t);\n  return paletteMonochrome(t); // 7\n}\n\n\nvec2 hash(vec2 p) {\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float n = mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                    dot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n                mix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                    dot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n  return n * 0.5 + 0.5;\n}\n\nfloat fbm(vec2 p, int octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100.0);\n  for (int i = 0; i < 6; i++) {\n    if (i >= octaves) break;\n    v += a * noise(p);\n    p = p * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n\n${t.map(e=>e.glsl).join("\n")}\n\nvoid main() {\n  // Map pixel to complex plane, keeping aspect ratio\n  vec2 uv = (gl_FragCoord.xy / u_resolution) * 2.0 - 1.0; // [-1,1]\n  float aspect = u_resolution.x / max(1.0, u_resolution.y);\n  uv.x *= aspect;\n\n  // span defines width of plane; scale uv accordingly and rotate\n  vec2 z = (rot(u_rotation) * uv) * (u_span * 0.5) + u_center;\n\n  vec3 col;\n  if (u_fractalType == -1) {\n    // Placeholder\n    col = vec3(0.0);\n  ${t.map(e=>`\n  } else if (u_fractalType == ${e.id}) {\n    ${1===e.id||2===e.id?`\n    vec2 pNorm = z / max(1e-6, u_span) + vec2(0.5);\n    float t = ${1===e.id?"sierpinskiTri":"sierpinskiCarpet"}(pNorm);\n    float shade = 1.0 - t;\n    col = getPalette(shade, u_palette);\n    `:3===e.id?"\n    vec2 pNorm2 = z / max(1e-6, u_span) + vec2(0.5);\n    float zSlice = 0.5 + 0.45 * sin(u_time * 0.25);\n    vec3 p3 = vec3(pNorm2, zSlice);\n    float t = mengerDepth(p3);\n    float shade = 1.0 - t;\n    col = getPalette(shade, u_palette);\n    ":4===e.id?"\n    vec2 pNorm2 = z / max(1e-6, u_span) + vec2(0.5);\n    float zSlice = 0.5 + 0.45 * sin(u_time * 0.22 + 1.0);\n    vec3 p3 = vec3(pNorm2, zSlice);\n    float t = sierpinskiPyramidDepth(p3);\n    float shade = 1.0 - t;\n    col = getPalette(shade, u_palette);\n    ":11===e.id?"\n    vec2 pNorm2 = z / max(1e-6, u_span) + vec2(0.5);\n    float zSlice = 0.5 + 0.45 * sin(u_time * 0.22 + 1.0);\n    vec3 p3 = vec3(pNorm2, zSlice);\n    col = colorDynamicMorph(p3);\n    ":14===e.id?"\n    vec2 pNorm2 = z / max(1e-6, u_span) + vec2(0.5);\n    float zSlice = 0.5 + 0.4 * sin(u_time * 0.2);\n    vec3 p3 = vec3(pNorm2, zSlice);\n    col = colorWeb3D(p3);\n    ":12===e.id||15===e.id?`\n    col = ${12===e.id?"colorStarJourney":"colorStar3D"}(uv);\n    `:`\n    col = ${0===e.id?"colorJulia":10===e.id?"colorPlasma":13===e.id?"colorLiquid":"colorEnergyCore"}(z);\n    `}\n    `).join("")}\n  } else {\n    // Overlay-only types: neutral background\n    col = vec3(0.0);\n  }\n\n  // Vignette for aesthetics\n  float d_vig = length(uv);\n  float vig = smoothstep(1.2, 0.2, d_vig);\n  col *= mix(0.85, 1.0, vig);\n\n  // Dithering to hide banding in smooth gradients\n  float noise = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  col += (noise - 0.5) * (1.0 / 255.0);\n\n  gl_FragColor = vec4(col, 1.0);\n}`})();function I(e,t){const n=s.createShader(e);if(s.shaderSource(n,t),s.compileShader(n),!s.getShaderParameter(n,s.COMPILE_STATUS)){const e=s.getShaderInfoLog(n);throw s.deleteShader(n),new Error("Shader compile error: "+e)}return n}function T(){u=function(e,t){const n=I(s.VERTEX_SHADER,e),a=I(s.FRAGMENT_SHADER,t),o=s.createProgram();if(s.attachShader(o,n),s.attachShader(o,a),s.bindAttribLocation(o,0,"a_position"),s.linkProgram(o),s.deleteShader(n),s.deleteShader(a),!s.getProgramParameter(o,s.LINK_STATUS)){const e=s.getProgramInfoLog(o);throw s.deleteProgram(o),new Error("Program link error: "+e)}return o}("\nattribute vec2 a_position;\nvoid main() {\n  gl_Position = vec4(a_position, 0.0, 1.0);\n}",S),s.useProgram(u);const e=new Float32Array([-1,-1,1,-1,-1,1,1,-1,1,1,-1,1]);f=s.createBuffer(),s.bindBuffer(s.ARRAY_BUFFER,f),s.bufferData(s.ARRAY_BUFFER,e,s.STATIC_DRAW),m.a_position=0,s.enableVertexAttribArray(m.a_position),s.vertexAttribPointer(m.a_position,2,s.FLOAT,!1,0,0),p.u_resolution=s.getUniformLocation(u,"u_resolution"),p.u_center=s.getUniformLocation(u,"u_center"),p.u_span=s.getUniformLocation(u,"u_span"),p.u_rotation=s.getUniformLocation(u,"u_rotation"),p.u_time=s.getUniformLocation(u,"u_time"),p.u_maxIter=s.getUniformLocation(u,"u_maxIter"),p.u_palette=s.getUniformLocation(u,"u_palette"),p.u_fractalType=s.getUniformLocation(u,"u_fractalType"),s.disable(s.DEPTH_TEST),s.disable(s.CULL_FACE),s.clearColor(0,0,0,1)}function L(){const e=a.getBoundingClientRect();let t=2;12!==c.fractalType&&15!==c.fractalType||(t=1.25);const n=Math.min(window.devicePixelRatio||1,t);n!==d&&(d=n);const r=Math.max(1,Math.floor(e.width*d)),i=Math.max(1,Math.floor(e.height*d));a.width===r&&a.height===i||(a.width=r,a.height=i,s.viewport(0,0,r,i),v=!0,o&&(o.width=r,o.height=i,x=!0))}function P(){l.iterationsValue.textContent=String(c.maxIter),l.zoomValue.textContent=c.scale.toFixed(2)+"×",l.rotationValue.textContent=Math.round(c.rotationDeg)+"°",l.speedValue.textContent=c.speed.toFixed(2)+"×"}function k(){r&&o&&r.clearRect(0,0,o.width,o.height)}function R(e){const t=Math.cos(e),n=Math.sin(e);return[t,-n,n,t]}function F(e,t){return{x:e[0]*t.x+e[1]*t.y,y:e[2]*t.x+e[3]*t.y}}function D(e,t){let n=(2*e-1)*(a.width/Math.max(1,a.height)),o=2*t-1;const r=F(R(c.rotationDeg*Math.PI/180),{x:n,y:o}),i=3*c.scale;return{x:r.x*(.5*i)+c.center.x,y:r.y*(.5*i)+c.center.y}}function z(e,t){const n=3*c.scale,o=F(R(-c.rotationDeg*Math.PI/180),{x:(e-c.center.x)/(.5*n),y:(t-c.center.y)/(.5*n)}),r=a.width/Math.max(1,a.height),i=o.x/Math.max(1e-6,r),l=o.y;return{x:.5*(i+1)*a.width,y:.5*(l+1)*a.height}}function E(e,t){const n=D(e,t),a=z(n.x,n.y);r.moveTo(a.x,a.y)}function q(e,t){const n=D(e,t),a=z(n.x,n.y);r.lineTo(a.x,a.y)}function C(){if(!s)return;L(),s.clear(s.COLOR_BUFFER_BIT),s.uniform2f(p.u_resolution,a.width,a.height),s.uniform2f(p.u_center,c.center.x,c.center.y),s.uniform1f(p.u_span,3*c.scale),s.uniform1f(p.u_rotation,c.rotationDeg*Math.PI/180),s.uniform1f(p.u_time,g*c.speed),s.uniform1i(p.u_maxIter,0|c.maxIter),s.uniform1i(p.u_palette,0|c.palette),s.uniform1i(p.u_fractalType,0|c.fractalType),s.drawArrays(s.TRIANGLES,0,6);const e=t(c.fractalType);e&&"overlay"===e.type?function(){if(!r||!o)return;k();const e=t(c.fractalType);e&&"overlay"===e.type&&e.draw&&e.draw(r,c.maxIter,d,{pathMoveToNorm:E,pathLineToNorm:q,worldFromNorm:D,planeToScreen:z},y)}():r&&k()}let A=0;function N(e){const t=(e-h)/1e3;h=e,c.playing&&(g+=t,v=!0),v&&(C(),v=!1),A=requestAnimationFrame(N)}function O(){cancelAnimationFrame(A),h=performance.now(),A=requestAnimationFrame(N)}let j=!1,U={x:0,y:0},B={active:!1,d0:0,scale0:1};function G(e,t){j=!0,U.x=e,U.y=t}function V(e,t){if(!j||B.active)return;const n=e-U.x,o=t-U.y;U.x=e,U.y=t;const r=function(e,t){const n=3*c.scale,o=a.width/Math.max(1,a.height),r=e/a.width*n*o,i=-t/a.height*n,l=c.rotationDeg*Math.PI/180,s=Math.cos(l),u=Math.sin(l);return{x:s*r-u*i,y:u*r+s*i}}(n,o);c.center.x-=r.x,c.center.y-=r.y,v=!0}function X(){j=!1}function W(e,t){const n=e.clientX-t.clientX,a=e.clientY-t.clientY;return Math.hypot(n,a)}function J(){try{!function(){const e={antialias:!1,preserveDrawingBuffer:!1,alpha:!1,powerPreference:"high-performance"};if(s=a.getContext("webgl",e)||a.getContext("experimental-webgl",e),!s)throw new Error("WebGL not supported");a.addEventListener("webglcontextlost",e=>{e.preventDefault(),cancelAnimationFrame(A)}),a.addEventListener("webglcontextrestored",()=>{T(),v=!0,O()})}(),T()}catch(t){return console.error(t),e="WebGL failed to initialize: "+t.message,void(i&&(i.classList.remove("hidden"),i.textContent=e||i.textContent))}var e;l.fractal&&(l.fractal.value=String(c.fractalType)),l.palette.value=String(c.palette),l.iterations.value=String(c.maxIter),l.zoom.value=String(c.scale),l.rotation.value=String(c.rotationDeg),l.speed.value=String(c.speed),P(),function(){function e(){const e=!!b.src;l.musicPlay&&(l.musicPlay.disabled=!e,l.musicPlay.setAttribute("aria-pressed",String(e&&!b.paused))),l.musicStop&&(l.musicStop.disabled=!e,l.musicStop.setAttribute("aria-pressed","false"))}l.fractal&&l.fractal.addEventListener("input",e=>{const n=0|parseInt(e.target.value,10);n!==c.fractalType&&(c.fractalType=n,function(e){const n=t(e);n&&n.defaults&&Object.assign(c,n.defaults),l.iterations.value=String(c.maxIter),l.zoom.value=String(c.scale),l.rotation.value=String(c.rotationDeg),P()}(n),y.ready=!1,v=!0)}),l.palette.addEventListener("input",e=>{c.palette=parseInt(e.target.value,10),v=!0,P()}),l.iterations.addEventListener("input",e=>{c.maxIter=parseInt(e.target.value,10),v=!0,P()}),l.zoom.addEventListener("input",e=>{c.scale=parseFloat(e.target.value),v=!0,P()}),l.rotation.addEventListener("input",e=>{c.rotationDeg=parseFloat(e.target.value),v=!0,P()}),l.speed.addEventListener("input",e=>{c.speed=parseFloat(e.target.value),v=!0,P()}),l.playPause.addEventListener("click",()=>{c.playing=!c.playing,l.playPause.textContent=c.playing?"Pause":"Play",l.playPause.setAttribute("aria-pressed",String(c.playing)),v=!0}),l.reset.addEventListener("click",()=>{Object.assign(c,{fractalType:0,palette:0,maxIter:200,scale:1,rotationDeg:0,speed:1,playing:!0,center:{x:-.2,y:0}}),l.fractal&&(l.fractal.value=String(c.fractalType)),l.palette.value=String(c.palette),l.iterations.value=String(c.maxIter),l.zoom.value=String(c.scale),l.rotation.value=String(c.rotationDeg),l.speed.value=String(c.speed),l.playPause.textContent="Pause",l.playPause.setAttribute("aria-pressed","true"),y.ready=!1,v=!0,P()}),l.recenter&&l.recenter.addEventListener("click",()=>{const e=0===c.fractalType?{x:-.2,y:0}:{x:0,y:0};c.center={x:e.x,y:e.y},v=!0}),l.musicFile&&l.musicFile.addEventListener("change",()=>{const t=l.musicFile.files&&l.musicFile.files[0];if(t){try{b.pause()}catch(e){}if(b.currentTime=0,w){try{URL.revokeObjectURL(w)}catch(e){}w=null}w=URL.createObjectURL(t),b.src=w,e()}}),l.musicPlay&&l.musicPlay.addEventListener("click",()=>{if(!b.src)return;const t=b.play();t&&"function"==typeof t.then?t.then(()=>e()).catch(t=>{console.warn("Music play failed:",t),e()}):e()}),l.musicStop&&l.musicStop.addEventListener("click",()=>{if(b.src){try{b.pause()}catch(e){}try{b.currentTime=0}catch(e){}e()}}),b.addEventListener("play",e),b.addEventListener("pause",e)}(),_(function(){try{return"1"===localStorage.getItem(M)}catch(e){return!1}}()),a.style.width="100%",a.style.height="100%",L(),C(),O()}a.addEventListener("touchstart",e=>{1===e.touches.length?G(e.touches[0].clientX,e.touches[0].clientY):2===e.touches.length&&(B.active=!0,B.d0=W(e.touches[0],e.touches[1]),B.scale0=c.scale)},{passive:!1}),a.addEventListener("touchmove",e=>{if(e.preventDefault(),1!==e.touches.length||B.active){if(2===e.touches.length){const t=W(e.touches[0],e.touches[1]),n=B.d0/Math.max(1,t);c.scale=Math.min(10,Math.max(.1,B.scale0*n)),l.zoom.value=String(c.scale),P(),v=!0}}else V(e.touches[0].clientX,e.touches[0].clientY)},{passive:!1}),a.addEventListener("touchend",()=>{B.active=!1,X()}),a.addEventListener("mousedown",e=>G(e.clientX,e.clientY)),window.addEventListener("mousemove",e=>V(e.clientX,e.clientY)),window.addEventListener("mouseup",X),a.addEventListener("wheel",function(e){e.preventDefault();const t=Math.exp(.001*-e.deltaY),n=a.getBoundingClientRect(),o=(e.clientX-n.left)*d,r=(e.clientY-n.top)*d,i=a.width/Math.max(1,a.height),s=(o/a.width*2-1)*i,u=r/a.height*2-1,f=c.rotationDeg*Math.PI/180,m=Math.cos(f)*s-Math.sin(f)*u,p=Math.sin(f)*s+Math.cos(f)*u,h=3*c.scale,g=m*(.5*h)+c.center.x,x=p*(.5*h)+c.center.y;c.scale=Math.min(10,Math.max(.1,c.scale/t)),l.zoom.value=String(c.scale);const y=3*c.scale,b=m*(.5*y)+c.center.x,w=p*(.5*y)+c.center.y;c.center.x+=g-b,c.center.y+=x-w,P(),v=!0},{passive:!1}),a.addEventListener("dblclick",function(e){e.preventDefault(),_(!(l.controls&&l.controls.classList.contains("hidden")))}),window.addEventListener("resize",()=>{v=!0}),document.addEventListener("keydown",e=>{if(e.defaultPrevented)return;if(e.ctrlKey||e.metaKey||e.altKey)return;const t=document.activeElement,n=t&&t.tagName?t.tagName.toUpperCase():"";"INPUT"===n||"SELECT"===n||"TEXTAREA"===n||t&&t.isContentEditable||"h"!==e.key&&"H"!==e.key||_(!(l.controls&&l.controls.classList.contains("hidden")))}),"loading"===document.readyState?document.addEventListener("DOMContentLoaded",J):J()})()})();